var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { DataSource } from '@angular/cdk/table';
import { of } from 'rxjs/observable/of';
var data = [];
var seed = [];
/**
 * Data source to provide what data should be rendered in the table. The observable provided
 * in connect should emit exactly the data that should be rendered by the table. If the data is
 * altered, the observable should emit that new set of data on the stream. In our case here,
 * we return a stream that contains only one set of data that doesn't change.
 */
var ExampleDataSource = /** @class */ (function (_super) {
    __extends(ExampleDataSource, _super);
    function ExampleDataSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ExampleDataSource.prototype.addData = function (_d) {
        data.push(_d);
    };
    ExampleDataSource.prototype.addSeed = function (_d) {
        seed.push(_d);
    };
    ExampleDataSource.prototype.clearData = function () {
        data = [];
    };
    ExampleDataSource.prototype.clearSeed = function () {
        seed = [];
    };
    ExampleDataSource.prototype.getData = function () {
        return data;
    };
    ExampleDataSource.prototype.getSeed = function () {
        return seed;
    };
    /** Connect function called by the table to retrieve one stream containing the data to render. */
    ExampleDataSource.prototype.connect = function () {
        var rows = [];
        // data.forEach(element => rows.push(element, { detailRow: true, element }));
        data.forEach(function (element) { return rows.push(element); });
        // console.log(rows);
        return of(rows);
    };
    ExampleDataSource.prototype.disconnect = function () { };
    return ExampleDataSource;
}(DataSource));
export { ExampleDataSource };
//# sourceMappingURL=example-data.js.map